#let sc(it) = math.class("normal",
  text(font: "", stylistic-set: 1, $cal(it)$) + h(0em)
)
#import "@preview/physica:0.9.2": *
#import "@preview/quick-maths:0.1.0": *

// The math stuff
#let mkdisplay(func) = (..args) => math.display(func(..args))
#let mkinline(func) = (..args) => inl(func(..args))
#let ds = math.display
#let inl = math.inline
#let dsum = ds(math.sum)
#let disum(x1,xn,fun) = $ds(sum_(i = x1)^(xn) fun)$
#let isum = inl(math.sum)
#let dpro = ds(math.product)
#let dpro = ds(math.product)
#let ipro = inl(math.product)
#let ang = $angle$
#let mang = $angle.arc$
#let line(content) = $arrow.l.r(content)$
#let seg(content) = $overline(content)$
#let conj(content) = $overline(content)$
#let arc(content) = $accent(content,paren.t)$
#let leq = $<=$
#let geq = $>=$
#let simeq = $tilde.equiv$
#let sim = $tilde$
#let sand = $sect$
#let sor = $union$
#let spn = $upright("span")$
#let Spn = $upright("Span")$
#let dlim(var, limit, fun) = $ds(lim_(var -> limit) fun)$
#let ilim(var, limit, fun) = $inline(lim_(var -> limit) fun)$
#let nlim(var, limit, fun) = $lim_(var -> limit) fun$
#let fall = $forall space$
#let est = $exists space$
#let fall2 = $space forall space$
#let est2 = $space exists space$
#let nest = $exists.not space$
#let est1 = $exists! space$
#let dot = $dprod$
#let crs = $times$
#let ap = $approx$
#let circ = $space circle.stroked.small space$
#let pp = $#h(0cm) + #h(0cm) +$
// Math styles
#let bba= $bb(a)$
#let bbb= $bb(b)$
#let bbc= $bb(c)$
#let bbd= $bb(d)$
#let bbe= $bb(e)$
#let bbf= $bb(f)$
#let bbg= $bb(g)$
#let bbh= $bb(h)$
#let bbi= $bb(i)$
#let bbj= $bb(j)$
#let bbk= $bb(k)$
#let bbl= $bb(l)$
#let bbm= $bb(m)$
#let bbn= $bb(n)$
#let bbo= $bb(o)$
#let bbp= $bb(p)$
#let bbq= $bb(q)$
#let bbr= $bb(r)$
#let bbs= $bb(s)$
#let bbt= $bb(t)$
#let bbu= $bb(u)$
#let bbv= $bb(v)$
#let bbw= $bb(w)$
#let bbx= $bb(x)$
#let bby= $bb(y)$
#let bbz= $bb(z)$
#let bbA= $bb(A)$
#let bbB= $bb(B)$
#let bbC= $bb(C)$
#let bbD= $bb(D)$
#let bbE= $bb(E)$
#let bbF= $bb(F)$
#let bbG= $bb(G)$
#let bbH= $bb(H)$
#let bbI= $bb(I)$
#let bbJ= $bb(J)$
#let bbK= $bb(K)$
#let bbL= $bb(L)$
#let bbM= $bb(M)$
#let bbN= $bb(N)$
#let bbO= $bb(O)$
#let bbP= $bb(P)$
#let bbQ= $bb(Q)$
#let bbR= $bb(R)$
#let bbS= $bb(S)$
#let bbT= $bb(T)$
#let bbU= $bb(U)$
#let bbV= $bb(V)$
#let bbW= $bb(W)$
#let bbX= $bb(X)$
#let bbY= $bb(Y)$
#let bbZ= $bb(Z)$
#let boa= $bold(a)$
#let bob= $bold(b)$
#let boc= $bold(c)$
#let bod= $bold(d)$
#let boe= $bold(e)$
#let bof= $bold(f)$
#let bog= $bold(g)$
#let boh= $bold(h)$
#let boi= $bold(i)$
#let boj= $bold(j)$
#let bok= $bold(k)$
#let bol= $bold(l)$
#let bom= $bold(m)$
#let bon= $bold(n)$
#let boo= $bold(o)$
#let bop= $bold(p)$
#let boq= $bold(q)$
#let bor= $bold(r)$
#let bos= $bold(s)$
#let bot= $bold(t)$
#let bou= $bold(u)$
#let bov= $bold(v)$
#let bow= $bold(w)$
#let box= $bold(x)$
#let boy= $bold(y)$
#let boz= $bold(z)$
#let boA= $bold(A)$
#let boB= $bold(B)$
#let boC= $bold(C)$
#let boD= $bold(D)$
#let boE= $bold(E)$
#let boF= $bold(F)$
#let boG= $bold(G)$
#let boH= $bold(H)$
#let boI= $bold(I)$
#let boJ= $bold(J)$
#let boK= $bold(K)$
#let boL= $bold(L)$
#let boM= $bold(M)$
#let boN= $bold(N)$
#let boO= $bold(O)$
#let boP= $bold(P)$
#let boQ= $bold(Q)$
#let boR= $bold(R)$
#let boS= $bold(S)$
#let boT= $bold(T)$
#let boU= $bold(U)$
#let boV= $bold(V)$
#let boW= $bold(W)$
#let boX= $bold(X)$
#let boY= $bold(Y)$
#let boZ= $bold(Z)$
#let cla= $cal(a)$
#let clb= $cal(b)$
#let clc= $cal(c)$
#let cld= $cal(d)$
#let cle= $cal(e)$
#let clf= $cal(f)$
#let clg= $cal(g)$
#let clh= $cal(h)$
#let cli= $cal(i)$
#let clj= $cal(j)$
#let clk= $cal(k)$
#let cll= $cal(l)$
#let clm= $cal(m)$
#let cln= $cal(n)$
#let clo= $cal(o)$
#let clp= $cal(p)$
#let clq= $cal(q)$
#let clr= $cal(r)$
#let cls= $cal(s)$
#let clt= $cal(t)$
#let clu= $cal(u)$
#let clv= $cal(v)$
#let clw= $cal(w)$
#let clx= $cal(x)$
#let cly= $cal(y)$
#let clz= $cal(z)$
#let clA= $cal(A)$
#let clB= $cal(B)$
#let clC= $cal(C)$
#let clD= $cal(D)$
#let clE= $cal(E)$
#let clF= $cal(F)$
#let clG= $cal(G)$
#let clH= $cal(H)$
#let clI= $cal(I)$
#let clJ= $cal(J)$
#let clK= $cal(K)$
#let clL= $cal(L)$
#let clM= $cal(M)$
#let clN= $cal(N)$
#let clO= $cal(O)$
#let clP= $cal(P)$
#let clQ= $cal(Q)$
#let clR= $cal(R)$
#let clS= $cal(S)$
#let clT= $cal(T)$
#let clU= $cal(U)$
#let clV= $cal(V)$
#let clW= $cal(W)$
#let clX= $cal(X)$
#let clY= $cal(Y)$
#let clZ= $cal(Z)$
#let sca= $sc(a)$
#let scb= $sc(b)$
#let scc= $sc(c)$
#let scd= $sc(d)$
#let sce= $sc(e)$
#let scf= $sc(f)$
#let scg= $sc(g)$
#let sch= $sc(h)$
#let sci= $sc(i)$
#let scj= $sc(j)$
#let sck= $sc(k)$
#let scl= $sc(l)$
#let scm= $sc(m)$
#let scn= $sc(n)$
#let sco= $sc(o)$
#let scp= $sc(p)$
#let scq= $sc(q)$
#let scr= $sc(r)$
#let scs= $sc(s)$
#let sct= $sc(t)$
#let scu= $sc(u)$
#let scv= $sc(v)$
#let scw= $sc(w)$
#let scx= $sc(x)$
#let scy= $sc(y)$
#let scz= $sc(z)$
#let scA= $sc(A)$
#let scB= $sc(B)$
#let scC= $sc(C)$
#let scD= $sc(D)$
#let scE= $sc(E)$
#let scF= $sc(F)$
#let scG= $sc(G)$
#let scH= $sc(H)$
#let scI= $sc(I)$
#let scJ= $sc(J)$
#let scK= $sc(K)$
#let scL= $sc(L)$
#let scM= $sc(M)$
#let scN= $sc(N)$
#let scO= $sc(O)$
#let scP= $sc(P)$
#let scQ= $sc(Q)$
#let scR= $sc(R)$
#let scS= $sc(S)$
#let scT= $sc(T)$
#let scU= $sc(U)$
#let scV= $sc(V)$
#let scW= $sc(W)$
#let scX= $sc(X)$
#let scY= $sc(Y)$
#let scZ= $sc(Z)$
#let sbs = $subset$
#let nsbs = $subset.not$
#let psbs = $subset.eq$
#let isbs = $subset.neq$
#let npsbs = $subset.eq.not$
#let sps = $supset$
#let nsps = $supset.not$
#let psps = $supset.eq$
#let isps = $supset.neq$
#let npsps = $supset.eq.not$
#let imap(set1,set2) = $iota_(set1 --> set2)$

#let opp = $plus.circle$
#let oxx = $times.circle$
#let dfr(enum,denom) = $ds(frac(enum,denom))$
#let ifr(enum,denom) = $inline(frac(enum,denom))$
#let fr(enum,denom) = $frac(enum,denom)$
#let nabla = $grad$
#let del = $grad$
#let vdots = $dots.v$
#let ddots = $dots.down$
#let udots = $dots.up$
#let cdots = $dots.h.c$
#let romt = math.mat.with(delim: "(")
#let sqmt = math.mat.with(delim: "[")
#let crmt = math.mat.with(delim: "{")
#let brmt = math.mat.with(delim: "|")
#let bbmt = math.mat.with(delim: "||")
#let romtd = mkdisplay(math.mat.with(delim: "("))
#let sqmtd = mkdisplay(math.mat.with(delim: "["))
#let crmtd = mkdisplay(math.mat.with(delim: "{"))
#let brmtd = mkdisplay(math.mat.with(delim: "|"))
#let bbmtd = mkdisplay(math.mat.with(delim: "||"))
#let rocs = math.cases.with(delim: "(")
#let sqcs = math.cases.with(delim: "[")
#let crcs = math.cases.with(delim: "{")
#let brcs = math.cases.with(delim: "|")
#let bbcs = math.cases.with(delim: "||")
#let rocsd = mkdisplay(math.cases.with(delim: "("))
#let sqcsd = mkdisplay(math.cases.with(delim: "["))
#let crcsd = mkdisplay(math.cases.with(delim: "{"))
#let brcsd = mkdisplay(math.cases.with(delim: "|"))
#let bbcsd = mkdisplay(math.cases.with(delim: "||"))
#let dromt = mkdisplay(dmat.with(delim: "("))
#let dsqmt = mkdisplay(dmat.with(delim: "["))
#let dcrmt = mkdisplay(dmat.with(delim: "{"))
#let dbrmt = mkdisplay(dmat.with(delim: "|"))
#let dbbmt = mkdisplay(dmat.with(delim: "||"))
#let dadromt = mkdisplay(admat.with(delim: "("))
#let dadsqmt = mkdisplay(admat.with(delim: "["))
#let dadcrmt = mkdisplay(admat.with(delim: "{"))
#let dadbrmt = mkdisplay(admat.with(delim: "|"))
#let dadbbmt = mkdisplay(admat.with(delim: "||"))
#let drromt = mkdisplay(rot2mat.with(delim: "("))
#let drsqmt = mkdisplay(rot2mat.with(delim: "["))
#let drcrmt = mkdisplay(rot2mat.with(delim: "{"))
#let drbrmt = mkdisplay(rot2mat.with(delim: "|"))
#let drbbmt = mkdisplay(rot2mat.with(delim: "||"))
#let rromt = rot2mat.with(delim: "(")
#let rsqmt = rot2mat.with(delim: "[")
#let rcrmt = rot2mat.with(delim: "{")
#let rbrmt = rot2mat.with(delim: "|")
#let rbbmt = rot2mat.with(delim: "||")
#let adromt = admat.with(delim: "(")
#let adsqmt = admat.with(delim: "[")
#let adcrmt = admat.with(delim: "{")
#let adbrmt = admat.with(delim: "|")
#let adbbmt = admat.with(delim: "||")
#let rovt = math.vec.with(delim: "(")
#let sqvt = math.vec.with(delim: "[")
#let crvt = math.vec.with(delim: "{")
#let brvt = math.vec.with(delim: "|")
#let bbvt = math.vec.with(delim: "||")
#let drovt = mkdisplay(math.vec.with(delim: "("))
#let dsqvt = mkdisplay(math.vec.with(delim: "["))
#let dcrvt = mkdisplay(math.vec.with(delim: "{"))
#let dbrvt = mkdisplay(math.vec.with(delim: "|"))
#let dbbvt = mkdisplay(math.vec.with(delim: "||"))
#let ni =  math.in.rev
#let nni =  math.in.rev.not
#let nin =  math.in.not
#let vdot = math.circle.filled.small 
#let sl = math.slash
#let R3 = $bbR^(3)$
#let R2 = $bbR^(2)$
#let R4 = $bbR^(2)$
#let Rn = $bbR^(n)$
#let Roo = $bbR^(oo)$
#let Coo = $bbC^(oo)$
#let Cin = $clC^(oo)$
#let C3 = $bbC^(3)$
#let C2 = $bbC^(2)$
#let C4 = $bbC^(4)$
#let Cn = $bbC^(n)$
#let cn = $clC^(n)$
#let c1 = $clC^(1)$
#let c2 = $clC^(2)$
#let xx = math.times 
#let mkdisplay(func) = (..args) => ds(func(..args))
#let nnm(content) = {
  math.equation(numbering: none, block: true, content) 
  }
#let prnm(number, content) = {h(1fr)
  set math.equation(numbering: n => {
    numbering("(1.1)", number)})
  content
}
#let scnm(m,e,content) = {h(1fr)
    set math.equation(numbering: n => {
    numbering("(1.1)", m, e)		// Manually builds a numbering with custom section and equation numbers
  } )
  content
}
#let prnm2(number, content) = {
  set math.equation(numbering: n => {
    numbering("(1.1)", number)})
  content
}
#let scnm2(m,e,content) = {
    set math.equation(numbering: n => {
    numbering("(1.1)", m, e)		// Manually builds a numbering with custom section and equation numbers
  } )
  content
}
#let eset = math.emptyset
#let lor = math.union.big
#let land = math.sect.big
#let nequiv = math.equiv.not
#let ddv = mkdisplay(dv)
#let dpdv = mkdisplay(pdv)
#let idv =  mkinline(dv)
#let ipdv = mkinline(pdv)
#let pr = $lt.curly$
// Units
#let dinte = ds(math.integral)
#let dintev = ds(math.integral.vol)
#let iintev = inl(math.integral.vol)
#let nintev = math.integral.vol
#let dintes = ds(math.integral.surf)
#let iintes = inl(math.integral.surf)
#let nintes = math.integral.surf
#let dintec = ds(math.integral.cont)
#let iintec = inl(math.integral.cont)
#let nintec = math.integral.cont
#let dinte4 = ds(math.integral.quad)
#let iinte4 = inl(math.integral.quad)
#let ninte4 = math.integral.quad
#let dinte3 = ds(math.integral.triple)
#let iinte3 = inl(math.integral.triple)
#let ninte3 = math.integral.triple
#let dinte2 = ds(math.integral.double)
#let iinte2 = inl(math.integral.double)
#let ninte2 = math.integral.double
#let dpdv(fun,var) = $ds(pdv(fun,var))$
#let Hom = math.upright("Hom") 